<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-07-11T01:55:08+09:00</updated><id>/feed.xml</id><title type="html">Grow Gardenia</title><subtitle>성장중🌱</subtitle><author><name>Gardenia</name></author><entry><title type="html">[Error]Git pull 에러</title><link href="/error/git-pull-%EC%97%90%EB%9F%AC/" rel="alternate" type="text/html" title="[Error]Git pull 에러" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>/error/git-pull-%EC%97%90%EB%9F%AC</id><content type="html" xml:base="/error/git-pull-%EC%97%90%EB%9F%AC/"><![CDATA[<h1 id="git-pull">git pull</h1>

<ul>
  <li>다른 repogitory 또는 로컬 브랜치를 가져와서 합치는 것</li>
  <li>git fetch와 git merge FETCH_HEAD의 약자이다.</li>
</ul>

<h2 id="what-is-fetch_head">What is FETCH_HEAD?</h2>

<ul>
  <li>원격 저장소로부터 가져온 브랜치의 HEAD를 의미</li>
  <li>원격 저장소로 부터 가져온 모든 브랜치의 HEAD를 .git/FETCH_HEAD에 기록함</li>
</ul>

<h3 id="error">ERROR</h3>

<p>git pull 하는 법을 구성하지 않았을 때 경고 문구가 나옴</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>warning: Pulling without specifying how to reconcile divergent branches is
discouraged. You can squelch this message by running one of the following
commands sometime before your next pull:

  git config pull.rebase false  # merge (the default strategy)
  git config pull.rebase true   # rebase
  git config pull.ff only       # fast-forward only

You can replace "git config" with "git config --global" to set a default
preference for all repositories. You can also pass --rebase, --no-rebase,
or --ff-only on the command line to override the configured default per
invocation.
</code></pre></div></div>

<p>다른 건 필요 없고 중간에 3개 명령어만 기억해두자!</p>

<blockquote>
  <p>git config pull.rebase false
pull 할 때 rebase를 하지 않고 merge한다.</p>
</blockquote>

<blockquote>
  <p>git config pull.rebase true
pull 할 때 rebase를 한다.</p>
</blockquote>

<blockquote>
  <p>git config pull.ff only
fast-foward 일때만 pull을 허용한다.</p>
</blockquote>

<h3 id="fast-foward-란">Fast-foward 란?</h3>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Fast-foward 관계 ⭕</th>
      <th>Fast-foward 관계 ❌</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>설명</td>
      <td>Merge 커밋을 남기지 않고 병합 가능</td>
      <td>Merge 커밋을 남겨야 병합 가능 충돌 없이 따라갈 수 없는 관계</td>
    </tr>
    <tr>
      <td> </td>
      <td>충돌 없이 앞선 커밋을 따라갈 수 있음</td>
      <td> </td>
    </tr>
    <tr>
      <td>즉, Fast-Foward 관계란 앞선 커밋을 충돌 없이 따라갈 수 있는 관계</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><img src="/img/fastfowardO.png" alt="Fast-foward 관계 ⭕ " /><img src="/img/fastfowardX.png" alt="Fast-foward 관계 ❌ " /></p>

<h2 id="merge-kind">Merge kind</h2>

<h3 id="보통의-병합ff">보통의 병합(–ff)</h3>

<p><code class="language-plaintext highlighter-rouge">git merge {branch name}</code>
현 브랜치와 병합할 브랜치가 Fast-Forward 관계 O: 병할할 브랜치(커밋)을 따라감. without Merge 커밋
현 브랜치와 병합할 브랜치가 Fast-Forward 관계 X : 병합할 브랜치와 병합됨. with Merge 커밋</p>

<h3 id="이기적인-병합no-ff">이기적인 병합(–no-ff)</h3>

<p><code class="language-plaintext highlighter-rouge">git merge --no-ff {branch name}</code>
현재 브랜치와 병합 대상의 관계가 Fast-Forward이던 아니던 무조건 Merge 커밋과 같이 병합</p>

<h3 id="소심한-병합ff-only">소심한 병합(–ff-only)</h3>

<p><code class="language-plaintext highlighter-rouge">git merge --ff-only {branch name}</code>
현재 브랜치와 병합 대상의 관계가 Fast-Forward인 경우에만 병합 진행
merge commit 생성 X</p>

<h3 id="양아치-병합squash">양아치 병합(–squash)</h3>

<p><code class="language-plaintext highlighter-rouge">git merge --squash {branch name}</code>
현재 브랜치에 병합 대상과의 차이나는 commit을 하나로 합쳐서 커밋</p>

<p>참조 :
<a href="https://wookkl.tistory.com/46">Git: pull strategy(전략,종류)</a>
<a href="https://minemanemo.tistory.com/46">[GIT] 병합(merge) 종류 별 완벽 설명</a></p>]]></content><author><name>Gardenia</name></author><category term="Error" /><category term="Error" /><category term="Git" /><summary type="html"><![CDATA[git pull 에러 정리]]></summary></entry><entry><title type="html">[Command]React와 TS 설치하기</title><link href="/command/React%EC%99%80-TS-%EC%84%A4%EC%B9%98/" rel="alternate" type="text/html" title="[Command]React와 TS 설치하기" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>/command/React%EC%99%80-TS-%EC%84%A4%EC%B9%98</id><content type="html" xml:base="/command/React%EC%99%80-TS-%EC%84%A4%EC%B9%98/"><![CDATA[<h1 id="react-설치">React 설치</h1>

<h2 id="아직-파일-없을-때">아직 파일 없을 때</h2>

<ol>
  <li>파일 만들 곳으로 이동</li>
  <li>React 설치
    <ul>
      <li><code class="language-plaintext highlighter-rouge">npx create-react-app 프로젝트명(파일이름)</code></li>
    </ul>
  </li>
</ol>

<h2 id="파일-있을-때">파일 있을 때</h2>

<ul>
  <li><u>주로 사용함</u> - github gui에서 repo만들어 clone 한 경우❗️</li>
</ul>

<ol>
  <li>클론한 파일 안으로 이동</li>
  <li>React 설치
    <ul>
      <li><code class="language-plaintext highlighter-rouge">npx create-react-app .</code></li>
    </ul>
  </li>
</ol>

<h1 id="typescript-설치">TypeScript 설치</h1>

<h2 id="react-설치-전-함께-설치-할-때">React 설치 전 함께 설치 할 때</h2>

<p><code class="language-plaintext highlighter-rouge">npx create-react-app 프로젝트명(파일이름) --template typescript</code></p>

<h2 id="typescript만-설치-할-때">TypeScript만 설치 할 때</h2>

<p><code class="language-plaintext highlighter-rouge">npm i typescript @types/node @types/react @types/react-dom @types/jest</code></p>

<h2 id="tsconfigjson-설치">tsconfig.json 설치</h2>

<p><code class="language-plaintext highlighter-rouge">tsc --init</code> - <code class="language-plaintext highlighter-rouge">npm i -g typescript</code>로 전역 설치 한 경우</p>

<p><a href="https://velog.io/@wonyuuu/TypeScript-React-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-TypeScript-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0">참고1</a><br />
<a href="https://velog.io/@welloff_jj/React-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-TypeScript%EB%A1%9C-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0-with-CRA-ESLint-Prettier-%EC%A0%81%EC%9A%A9">참고2</a></p>]]></content><author><name>Gardenia</name></author><category term="Command" /><category term="Tips" /><category term="Command" /><summary type="html"><![CDATA[프로젝트 시작할 때 사용하자🔥]]></summary></entry><entry><title type="html">[Command]Fork 한 Repo Update💻</title><link href="/command/Fork%ED%95%9C-Repo-Update/" rel="alternate" type="text/html" title="[Command]Fork 한 Repo Update💻" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>/command/Fork%ED%95%9C-Repo-Update</id><content type="html" xml:base="/command/Fork%ED%95%9C-Repo-Update/"><![CDATA[<h1 id="fork-한-repo-update">Fork 한 Repo Update💻</h1>

<ol>
  <li>내 로컬에 Fork Clone</li>
</ol>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git clone 포크repo주소</code></li>
</ul>

<ol>
  <li>Clone 한 프로젝트 디렉토리 이동 -&gt; 리모트 저장소 확인</li>
</ol>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git remote -v</code></li>
</ul>

<ol>
  <li>리모트 저장소에 upstream 추가</li>
</ol>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git remote add 등록이름 원본repo주소 </code></li>
</ul>

<ol>
  <li>추가 확인해보기 - 2번 과 동일</li>
  <li>원본 저장소 fetch - 가져오기</li>
</ol>

<ul>
  <li><code class="language-plaintext highlighter-rouge">it fetch 등록이름</code></li>
</ul>

<ol>
  <li>원본 저장소 merge - 합치기</li>
</ol>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git merge 등록이름/브랜치이름</code></li>
</ul>

<ol>
  <li>포크저장소로 push</li>
</ol>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git push</code></li>
</ul>

<p><a href="https://velog.io/@k904808/Fork-%ED%95%9C-Repository-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EA%B8%B0">참고</a></p>]]></content><author><name>Gardenia</name></author><category term="Command" /><category term="Tips" /><category term="Command" /><summary type="html"><![CDATA[Fork Repo 관리시 필요할 듯]]></summary></entry><entry><title type="html">[Tips]용어 사전</title><link href="/tips/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[Tips]용어 사전" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>/tips/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="/tips/%EC%9A%A9%EC%96%B4%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">알파벳 순 정리</code></p>

<h2 id="props">Props</h2>

<h2 id="routing">Routing</h2>

<h2 id="rendering">Rendering</h2>

<h2 id="state">State</h2>]]></content><author><name>Gardenia</name></author><category term="Tips" /><category term="Tips" /><summary type="html"><![CDATA[용어 정리하기]]></summary></entry><entry><title type="html">[Tips]MYSQL 문법</title><link href="/tips/mysql-%EB%AC%B8%EB%B2%95%EC%A0%95%EB%A6%AC/" rel="alternate" type="text/html" title="[Tips]MYSQL 문법" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>/tips/mysql-%EB%AC%B8%EB%B2%95%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="/tips/mysql-%EB%AC%B8%EB%B2%95%EC%A0%95%EB%A6%AC/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">아래 문법 설명은 w3schools의 설명을 기초로 작성되었음</code></p>

<h1 id="basic">BASIC</h1>

<h2 id="select">SELECT</h2>

<ul>
  <li>데이터 선택</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column1, column2, ...
FROM table_name;
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>SELECT CustomerName, City FROM Customers;</p>
</blockquote>

<ul>
  <li>모든 데이터를 선택할때 <code class="language-plaintext highlighter-rouge">*</code>를 쓴다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT * FROM table_name;
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>SELECT * FROM Customers;</p>
</blockquote>

<h3 id="select-distinct문">SELECT DISTINCT문</h3>

<ul>
  <li>SELECT 절 바로 뒤에 DISTINCT 문을 넣고 그 뒤에 가져오길 원하는 칼럼을 나열하면 중복값이 제거된 데이터를 가져올 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT DISTINCT column1, column2, ...
FROM table_name;
</code></pre></div></div>

<h2 id="where">WHERE</h2>

<ul>
  <li>필터링</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column1, column2, ...
FROM table_name
WHERE condition;
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>SELECT * FROM Customers
WHERE Country=’Mexico’;</p>
</blockquote>

<h2 id="and-or-및-not">AND, OR 및 NOT</h2>

<ul>
  <li>
    <p>WHERE 절과 결합 가능</p>
  </li>
  <li>
    <p>AND 구문 : 다 포함 된 것 조회</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column1, column2, ...
FROM table_name
WHERE condition1 AND condition2 AND condition3 ...;
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>SELECT * FROM Customers
WHERE Country=’Germany’ AND City=’Berlin’;</p>
</blockquote>

<ul>
  <li>OR 구문 : 하나라도 포함 되면 조회</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column1, column2, ...
FROM table_name
WHERE condition1 OR condition2 OR condition3 ...;
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>SELECT * FROM Customers
WHERE City=’Berlin’ OR City=’München’;</p>
</blockquote>

<ul>
  <li>NOT 구문 : 특정 값을 제외 한 조회</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column1, column2, ...
FROM table_name
WHERE NOT condition;
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>SELECT * FROM Customers
WHERE NOT Country=’Germany’;</p>
</blockquote>

<h3 id="섞어쓰기">섞어쓰기</h3>

<ul>
  <li>국가가 “독일”이 아니고 “미국”이 아닌 “고객”의 모든 필드</li>
</ul>

<blockquote>
  <p>SELECT * FROM Customers
WHERE NOT Country=’Germany’ AND NOT Country=’USA’;</p>
</blockquote>

<h2 id="order-by">ORDER BY</h2>

<ul>
  <li>오름차순, 내림차순으로 결과를 정렬함</li>
</ul>

<p>오름차순</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column1, column2, ...
FROM table_name
ORDER BY column1, column2, ... (ASC)
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>SELECT * FROM Customers
ORDER BY Country;</p>
</blockquote>

<p>내림차순</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column1, column2, ...
FROM table_name
ORDER BY column1, column2, ...DESC;
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>SELECT * FROM Customers
ORDER BY Country DESC;</p>
</blockquote>

<p>ex. 여러 열 1 -&gt; “국가”를 기준으로 오름차순으로 정렬되고 “CustomerName” 열을 기준으로 내림차순으로 정렬</p>

<blockquote>
  <p>SELECT * FROM Customers
ORDER BY Country ASC, CustomerName DESC;</p>
</blockquote>

<h2 id="insert-into">INSERT INTO</h2>

<ul>
  <li>테이블에 새 레코드 삽입</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
</code></pre></div></div>

<p>테이블의 모든 열에 값을 추가하는 경우</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INSERT INTO table_name
VALUES (value1, value2, value3, ...);
</code></pre></div></div>

<p>ex. “CustomerName”, “City” 및 “Country” 열에만 데이터를 삽입</p>

<blockquote>
  <p>INSERT INTO Customers (CustomerName, City, Country)
VALUES (‘Cardinal’, ‘Stavanger’, ‘Norway’);</p>
</blockquote>

<h2 id="null">NULL</h2>

<ul>
  <li>값이 없는 필드
NULL 값은 0 값 또는 공백이 포함된 필드와 다르다. NULL 값이 있는 필드는 레코드 생성 중에 <code class="language-plaintext highlighter-rouge">비어 있는</code> 필드</li>
</ul>

<p>IS NULL -&gt; 비어 있는 것 조회</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_names
FROM table_name
WHERE column_name IS NULL;
</code></pre></div></div>

<p>ex. 주소가 비어있는 고객 조회</p>

<blockquote>
  <p>SELECT CustomerName, ContactName, Address
FROM Customers
WHERE Address IS NULL;</p>
</blockquote>

<p>IS NOT NULL -&gt; 비어 있지 않은 것 조회</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_names
FROM table_name
WHERE column_name IS NOT NULL;
</code></pre></div></div>

<p>ex. 주소가 비어있지 않은 고객 조회</p>

<blockquote>
  <p>SELECT CustomerName, ContactName, Address
FROM Customers
WHERE Address IS NOT NULL;`</p>
</blockquote>

<h2 id="update">UPDATE</h2>

<ul>
  <li>기존의 레코드 수정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
</code></pre></div></div>

<ul>
  <li>WHERE절 을 생략하면 테이블의 <code class="language-plaintext highlighter-rouge">모든 레코드가 업데이트</code></li>
</ul>

<p>ex. CustomerID가 1인 고객의 담당자와 도시를 업데이트!</p>

<blockquote>
  <p>UPDATE Customers
SET ContactName = ‘Alfred Schmidt’, City= ‘Frankfurt’
WHERE CustomerID = 1;</p>
</blockquote>

<p>ex. 나라가 멕시코인 고객들의 담당자를 Juan으로 변경</p>

<blockquote>
  <p>UPDATE Customers
SET ContactName=’Juan’
WHERE Country=’Mexico’;</p>
</blockquote>

<h2 id="delete">DELETE</h2>

<ul>
  <li>기존 레코드 삭제</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DELETE FROM table_name WHERE condition;
</code></pre></div></div>

<ul>
  <li>WHERE절 을 생략하면 테이블의 <code class="language-plaintext highlighter-rouge">모든 레코드가 삭제</code></li>
</ul>

<p>ex. 고객명이 ‘Alfreds Futterkiste’인 칼럼 삭제</p>

<blockquote>
  <p>DELETE FROM Customers WHERE CustomerName=’Alfreds Futterkiste’;</p>
</blockquote>

<p>ex. 모든 기록 삭제</p>

<blockquote>
  <p>DELETE FROM table_name;</p>
</blockquote>

<h2 id="limit">LIMIT</h2>

<p>(sql/MS액세스, MySQL, Oracle 방법이 다름)</p>

<ul>
  <li><a href="https://www.w3schools.com/sql/sql_top.asp">SELECT TOP</a></li>
  <li>제한된 수의 레코드를 선택</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table_name
WHERE condition
LIMIT number;
</code></pre></div></div>

<p>ex. 처음 세개의 레코드 조회</p>

<blockquote>
  <p>SELECT * FROM Customers
LIMIT 3;</p>
</blockquote>

<h2 id="min--max">MIN() &amp; MAX()</h2>

<ul>
  <li>선택열의 가장 작은(큰) 값 반환</li>
</ul>

<p>MIN()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MIN(column_name)
FROM table_name
WHERE condition;
</code></pre></div></div>

<p>ex. 가장 저렴한 가격 찾기</p>

<blockquote>
  <p>SELECT MIN(Price) AS SmallestPrice
FROM Products;</p>
</blockquote>

<p>MAX()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT MAX(column_name)
FROM table_name
WHERE condition;
</code></pre></div></div>

<p>ex. 가장 비싼 가격 찾기</p>

<blockquote>
  <p>SELECT MAX(Price) AS LargestPrice
FROM Products;
** AS : SELECT 별칭 주기</p>
</blockquote>

<h2 id="count-avg-sum">COUNT(), AVG(), SUM()</h2>

<ul>
  <li>
    <p>NULL 값 무시</p>
  </li>
  <li>
    <p>COUNT()</p>
    <ul>
      <li>지정된 기준과 일치하는 행의 수를 반환</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT COUNT(column_name)
FROM table_name
WHERE condition;
</code></pre></div></div>

<p>ex. 제품수 반환하기</p>

<blockquote>
  <p>SELECT COUNT(ProductID)
FROM Products;</p>
</blockquote>

<ul>
  <li>AVG()
    <ul>
      <li>숫자 열의 평균 반환</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT AVG(column_name)
FROM table_name
WHERE condition;
</code></pre></div></div>

<p>ex. 제품의 평균 가격</p>

<blockquote>
  <p>SELECT AVG(Price)
FROM Products;</p>
</blockquote>

<ul>
  <li>SUM()
    <ul>
      <li>숫자 열의 총 합</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT SUM(column_name)
FROM table_name
WHERE condition;
</code></pre></div></div>

<p>ex. Quantity 합계 조회</p>

<blockquote>
  <p>SELECT SUM(Quantity)
FROM OrderDetails;</p>
</blockquote>

<h2 id="like">LIKE</h2>

<ul>
  <li>WHERE열의 특정 패턴을 검색</li>
  <li>%(0,1 또는 여러 문자를 나타냄) 와 _(하나의 단일 문자 나타냄) 함께 자주 사용</li>
  <li>AND 나 OR 을 결합해서 쓸 수 있음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column1, column2, ...
FROM table_name
WHERE columnN LIKE pattern;
</code></pre></div></div>

<p>ex. 고객명이 a로 시작하는 모든 고객 조회</p>

<blockquote>
  <p>SELECT * FROM Customers
WHERE CustomerName LIKE ‘a%’;</p>
</blockquote>

<p>ex. 첫글자가 a로 시작하고 3글자 이상인 CustomerName을 가진 고객 모두 조회</p>

<blockquote>
  <p>SELECT * FROM Customers
WHERE CustomerName LIKE ‘a__%’;</p>
</blockquote>

<p>ex. 첫글자가 a로 시작하고 마지막 글자가 o로 끝나는 CustomerName을 가진 고객 모두 조회</p>

<blockquote>
  <p>SELECT * FROM Customers
WHERE ContactName LIKE ‘a%o’;</p>
</blockquote>

<p>ex. 첫글자가 a로 시작하지 않는 CustomerName을 가진 고객 모두 조회</p>

<blockquote>
  <p>SELECT * FROM Customers
WHERE CustomerName NOT LIKE ‘a%’;</p>
</blockquote>

<h2 id="in">IN</h2>

<ul>
  <li>여러 값을 지정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1, value2, ...);
</code></pre></div></div>

<p>or</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table_name
WHERE column_name IN (SELECT STATEMENT);
</code></pre></div></div>

<p>ex. 나라가 독일, 프랑스, 영국인 모든 고객 조회</p>

<blockquote>
  <p>SELECT * FROM Customers
WHERE Country IN (‘Germany’, ‘France’, ‘UK’);</p>
</blockquote>

<p>ex. Suppliers와 동일한 국가의 모든 고객 조회</p>

<blockquote>
  <p>SELECT * FROM Customers
WHERE Country IN (SELECT Country FROM Suppliers);</p>
</blockquote>

<h2 id="between">BETWEEN</h2>

<ul>
  <li>주어진 범위 내에서 값을 선택
    <ul>
      <li>값은 숫자, 텍스트 또는 날짜일 수 있음</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;
</code></pre></div></div>

<p>ex. 가격이 10에서 20사이인 제품 조회</p>

<blockquote>
  <p>SELECT * FROM Products
WHERE Price BETWEEN 10 AND 20;</p>
</blockquote>

<p>ex. OrderDate가 1996년 7월 1일과 1996년 7월 31일 사이의 주문을 조회</p>

<blockquote>
  <p>SELECT * FROM Orders
WHERE OrderDate BETWEEN #07/01/1996# AND #07/31/1996#;</p>
</blockquote>

<h2 id="aliases별칭">Aliases(별칭)</h2>

<p>열 구문</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name AS alias_name
FROM table_name;
</code></pre></div></div>

<p>테이블 구문</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table_name AS alias_name;
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>SELECT CustomerID AS ID, CustomerName AS Customer
FROM Customers;</p>
</blockquote>

<h2 id="join">JOIN</h2>

<ul>
  <li>두 개 이상의 테이블에서 행을 결합하는 데 사용</li>
</ul>

<p><img src="/img/joins.png" alt="join 그림" /></p>

<h3 id="inner-join">INNER JOIN</h3>

<ul>
  <li>두 테이블에서 일치하는 값을 가진 레코드를 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table1
INNER JOIN table2
ON table1.column_name = table2.column_name;
</code></pre></div></div>

<p>ex. 고객 정보가 있는 모든 주문 조회</p>

<blockquote>
  <p>SELECT Orders.OrderID, Customers.CustomerName
FROM Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;</p>
</blockquote>

<h3 id="left-join">LEFT JOIN</h3>

<ul>
  <li>왼쪽 테이블의 모든 레코드를 반환하고 오른쪽 테이블의 일치하는 레코드를 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name;
</code></pre></div></div>

<p>ex. 모든 고객과 고객이 가질 수 있는 모든 주문을 조회</p>

<blockquote>
  <p>SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID
ORDER BY Customers.CustomerName;</p>
</blockquote>

<h3 id="right-join">RIGHT JOIN</h3>

<ul>
  <li>오른쪽 테이블의 모든 레코드를 반환하고 왼쪽 테이블의 일치하는 레코드를 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table1
RIGHT JOIN table2
ON table1.column_name = table2.column_name;
</code></pre></div></div>

<p>ex. 모든 직원과 직원이 내린 모든 주문을 조회</p>

<blockquote>
  <p>SELECT Orders.OrderID, Employees.LastName, Employees.FirstName
FROM Orders
RIGHT JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID
ORDER BY Orders.OrderID;</p>
</blockquote>

<h3 id="full-join">FULL JOIN</h3>

<ul>
  <li>왼쪽 또는 오른쪽 테이블에 일치하는 항목이 있는 경우 모든 레코드를 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name = table2.column_name
WHERE condition;
</code></pre></div></div>

<p>ex. 모든 고객과 모든 주문 선택</p>

<blockquote>
  <p>SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
FULL OUTER JOIN Orders ON Customers.CustomerID=Orders.CustomerID
ORDER BY Customers.CustomerName;</p>
</blockquote>

<h3 id="self-join">SELF JOIN</h3>

<ul>
  <li>테이블은 자신과 조인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table1 T1, table1 T2
WHERE condition;
</code></pre></div></div>

<ul>
  <li>T1 그리고 T2 동일한 테이블에 대한 다른 테이블 별칭</li>
</ul>

<p>ex. 같은 도시에 있는 고객과 일치</p>

<blockquote>
  <p>SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID &lt;&gt; B.CustomerID
AND A.City = B.City
ORDER BY A.City;</p>
</blockquote>

<h2 id="union">UNION</h2>

<ul>
  <li>두 개 이상의 결과 집합을 결합하는 데 사용되는 <code class="language-plaintext highlighter-rouge">SELECT</code>문
조건</li>
</ul>

<ol>
  <li><code class="language-plaintext highlighter-rouge">SELECT</code>안의 모든 명령문 <code class="language-plaintext highlighter-rouge">UNION</code>에는 동일한 수의 열이 있어야함</li>
  <li>열에도 유사한 데이터 유형이 있어야함</li>
  <li>모든 <code class="language-plaintext highlighter-rouge">SELECT</code>문의 열도 같은 순서여야함</li>
</ol>

<h3 id="union-1">UNION</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
</code></pre></div></div>

<p>ex. “Customers” 및 “Suppliers” 테이블 모두에서 도시(고유한 값만)를 조회</p>

<blockquote>
  <p>SELECT City FROM Customers
UNION
SELECT City FROM Suppliers
ORDER BY City;</p>
</blockquote>

<h3 id="union-all">UNION ALL</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT City FROM Customers
UNION ALL
SELECT City FROM Suppliers
ORDER BY City;
</code></pre></div></div>

<p>ex. “Customers” 및 “Suppliers” 테이블 모두에서 독일 도시(중복 값도 포함)를 조회</p>

<blockquote>
  <p>SELECT City, Country FROM Customers
WHERE Country=’Germany’
UNION ALL
SELECT City, Country FROM Suppliers
WHERE Country=’Germany’
ORDER BY City;</p>
</blockquote>

<h2 id="group-by">GROUP BY</h2>

<ul>
  <li>하나 이상의 열로 결과 집합을 그룹화하기 위해 집계 함수(<code class="language-plaintext highlighter-rouge">COUNT()</code>, <code class="language-plaintext highlighter-rouge">MAX()</code>, <code class="language-plaintext highlighter-rouge">MIN()</code>, <code class="language-plaintext highlighter-rouge">SUM()</code>, <code class="language-plaintext highlighter-rouge">AVG()</code>) 와 함께 자주 사용</li>
  <li>특정 컬럼 이름을 지정(column-names)해주면 그 컬럼의 UNIQUE한 값에 따라서 데이터를 그룹 짓고, 중복된 열은 제거 됨</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
ORDER BY column_name(s);
</code></pre></div></div>

<p>ex. 각 국가의 고객 수를 조회</p>

<blockquote>
  <p>SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country;</p>
</blockquote>

<h2 id="having">HAVING</h2>

<ul>
  <li>GROUP BY한 결과에 조건을 붙이고 싶을때 사용</li>
  <li>GROUP BY의 WHERE 절</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
HAVING condition
ORDER BY column_name(s);
</code></pre></div></div>

<p>ex. 각 국가의 고객 수를 조회 ( 고객이 5명 이상인 국가만 포함하여)</p>

<blockquote>
  <p>SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) &gt; 5;</p>
</blockquote>

<h2 id="exists">EXISTS</h2>

<ul>
  <li>하위 쿼리에 레코드가 있는지 테스트하는 데 사용</li>
  <li>하위 쿼리가 하나 이상의 레코드를 반환하는 경우 연산자는 TRUE를 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);
</code></pre></div></div>

<p>ex. TRUE를 반환하고 제품 가격이 20 미만인 공급자를</p>

<blockquote>
  <p>SELECT SupplierName
FROM Suppliers
WHERE EXISTS (SELECT ProductName FROM Products WHERE Products.SupplierID = Suppliers.supplierID AND Price &lt; 20);</p>
</blockquote>

<h2 id="any">ANY</h2>

<ul>
  <li>결과로 boolean 값을 반환합니다.</li>
  <li>하위 쿼리 값 중 하나라도 조건을 충족하는 경우 TRUE를 반환</li>
  <li>범위의 값 중 하나에 대해 작업이 참인 경우 조건이 참임을 의미</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table_name
WHERE column_name operator ANY
  (SELECT column_name
  FROM table_name
  WHERE condition);
</code></pre></div></div>

<p>ex. OrderDetails 테이블에서 Quantity가 10인 레코드를 찾으면 ProductName을 조회
(Quantity 열의 일부 값이 10이므로 TRUE가 반환됨)</p>

<blockquote>
  <p>SELECT ProductName
FROM Products
WHERE ProductID = ANY
(SELECT ProductID
FROM OrderDetails
WHERE Quantity = 10);</p>
</blockquote>

<h2 id="all">ALL</h2>

<ul>
  <li>결과로 boolean 값을 반환합니다.</li>
  <li>하위 쿼리 값 중 하나라도 조건을 충족하는 경우 TRUE를 반환</li>
  <li><code class="language-plaintext highlighter-rouge">SELECT</code>, <code class="language-plaintext highlighter-rouge">WHERE</code> 및 <code class="language-plaintext highlighter-rouge">HAVING</code>문과 함께 사용</li>
</ul>

<p>USE SELECT</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT ALL column_name(s)
FROM table_name
WHERE condition;
</code></pre></div></div>

<p>USE WHERE or HAVING</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column_name(s)
FROM table_name
WHERE column_name operator ALL
  (SELECT column_name
  FROM table_name
  WHERE condition);
</code></pre></div></div>

<p>ex. 모든 제품 이름을 조회</p>

<blockquote>
  <p>SELECT ALL ProductName
FROM Products
WHERE TRUE;</p>
</blockquote>

<p>ex. OrderDetails 테이블의 모든 레코드에 Quantity가 10인 경우 ProductName을 조회
Quantity 열에 값이 10일 뿐만 아니라 다양한 값이 있기 때문에 당연히 FALSE를 반환</p>

<blockquote>
  <p>SELECT ProductName
FROM Products
WHERE ProductID = ALL
(SELECT ProductID
FROM OrderDetails
WHERE Quantity = 10);</p>
</blockquote>

<h2 id="select-into">SELECT INTO</h2>

<ul>
  <li>한 테이블의 데이터를 새 테이블로 복사</li>
</ul>

<p>모든 열 복사</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT *
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
</code></pre></div></div>

<p>일부 열만 복사</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column1, column2, column3, ...
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
</code></pre></div></div>

<p>ex. 고객의 백업 복사본을 생성</p>

<blockquote>
  <p>SELECT * INTO CustomersBackup2017
FROM Customers;</p>
</blockquote>

<p>ex. IN절을 사용하여 테이블을 다른 데이터베이스의 새 테이블로 복사</p>

<blockquote>
  <p>SELECT * INTO CustomersBackup2017 IN ‘Backup.mdb’
FROM Customers;</p>
</blockquote>

<p>ex. 몇 개의 열만 새 테이블에 복사</p>

<blockquote>
  <p>SELECT CustomerName, ContactName INTO CustomersBackup2017
FROM Customers;</p>
</blockquote>

<ul>
  <li>다른 스키마를 사용하여 비어 있는 새 테이블을 만드는 데 사용할 수도 있음
    <ul>
      <li><code class="language-plaintext highlighter-rouge">WHERE</code>쿼리가 데이터를 반환하지 않도록 하는 절을 추가하기만 하면 됨</li>
    </ul>
  </li>
</ul>

<p>ex.</p>

<blockquote>
  <p>SELECT * INTO newtable
FROM oldtable
WHERE 1 = 0;</p>
</blockquote>

<h2 id="insert-into-select">INSERT INTO SELECT</h2>

<ul>
  <li>select 한 것ㅇ르 insert 하는 구문</li>
  <li>select하는 테이블과 insert할 테이블의 컬럼은 일치해야 함</li>
</ul>

<p>한 테이블의 모든 열을 다른 테이블로 복사</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INSERT INTO table2
SELECT * FROM table1
WHERE condition;
</code></pre></div></div>

<p>한 테이블의 일부 열만 다른 테이블로 복사</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INSERT INTO table2 (column1, column2, column3, ...)
SELECT column1, column2, column3, ...
FROM table1
WHERE condition;
</code></pre></div></div>

<p>ex.”공급자”를 “고객”으로 복사
(데이터로 채워지지 않은 열에는 NULL이 포함됨).</p>

<blockquote>
  <p>INSERT INTO Customers (CustomerName, City, Country)
SELECT SupplierName, City, Country FROM Suppliers;</p>
</blockquote>

<h2 id="case">CASE</h2>

<ul>
  <li>if 문과 같은 기능</li>
  <li>조건을 통과하고 첫 번째 조건은 (if-then-else 명령문 등)을 충족하는 값을 반환</li>
  <li>조건이 true이면 읽기를 중지하고 결과를 반환</li>
  <li>조건이 참이 아니면 ELSE절의 값을 반환</li>
  <li>없는 경우 ELSE 부분이고 조건이 참이 아니면 NULL을 반환</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CASE
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    WHEN conditionN THEN resultN
    ELSE result
END;
</code></pre></div></div>

<p>ex. City별로 고객을 주문합니다. 그러나 City가 NULL이면 국가별 조회</p>

<blockquote>
  <p>SELECT CustomerName, City, Country
FROM Customers
ORDER BY
(CASE</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WHEN City IS NULL THEN Country
ELSE City
</code></pre></div></div>

<p>END);</p>

<h1 id="database">DATABASE</h1>

<h2 id="create-database">CREATE DATABASE</h2>

<ul>
  <li>새 SQL 데이터베이스를 생성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE DATABASE databasename;
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>CREATE DATABASE testDB;</p>
</blockquote>

<h2 id="drop-database">DROP DATABASE</h2>

<ul>
  <li>기존 SQL 데이터베이스를 삭제</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DROP DATABASE databasename;
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>DROP DATABASE testDB;</p>
</blockquote>

<h2 id="backup-database">BACKUP DATABASE</h2>

<ul>
  <li>SQL Server에서 기존 SQL 데이터베이스의 전체 백업을 만듬</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BACKUP DATABASE databasename
TO DISK = 'filepath';
</code></pre></div></div>

<p>ex. 기존 데이터베이스 “testDB”의 전체 백업을 D 디스크에 생성</p>

<blockquote>
  <p>BACKUP DATABASE testDB
TO DISK = ‘D:\backups\testDB.bak’;</p>
</blockquote>

<h3 id="backup-with-differential">BACKUP WITH DIFFERENTIAL</h3>

<ul>
  <li>전체 백업 이후 변경된 부분만 백업</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BACKUP DATABASE databasename
TO DISK = 'filepath'
WITH DIFFERENTIAL;
</code></pre></div></div>

<p>ex.</p>

<blockquote>
  <p>BACKUP DATABASE testDB
TO DISK = ‘D:\backups\testDB.bak’
WITH DIFFERENTIAL;</p>
</blockquote>

<h2 id="create-table">CREATE TABLE</h2>

<ul>
  <li>데이터베이스에 새 테이블을 생성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    column3 datatype,
   ....
);
</code></pre></div></div>

<p>ex. PersonID, LastName, FirstName, Address 및 City의 5개 열이 포함된 “Persons”라는 테이블을 생성</p>

<blockquote>
  <p>CREATE TABLE Persons (</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PersonID int,
LastName varchar(255),
FirstName varchar(255),
Address varchar(255),
'City varchar(255)
</code></pre></div></div>

<p>);</p>

<h2 id="drop-table">DROP TABLE</h2>

<ul>
  <li>데이터베이스의 기존 테이블을 삭제</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DROP TABLE table_name;
</code></pre></div></div>

<p>ex. 기존 테이블 “Shippers”를 삭제</p>

<blockquote>
  <p>DROP TABLE Shippers;</p>
</blockquote>

<h2 id="alter-table">ALTER TABLE</h2>

<ul>
  <li>기존 테이블의 열을 추가, 삭제 또는 수정</li>
  <li>기존 테이블에 다양한 제약 조건을 추가 및 삭제</li>
</ul>

<h3 id="열-추가">열 추가</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALTER TABLE table_name
ADD column_name datatype;
</code></pre></div></div>

<p>ex. “Customers” 테이블에 “Email” 열을 추가</p>

<blockquote>
  <p>ALTER TABLE Customers
ADD Email varchar(255);</p>
</blockquote>

<h3 id="열-삭제">열 삭제</h3>

<ul>
  <li>일부 데이터베이스 시스템에서는 열 삭제를 허용하지 않음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALTER TABLE table_name
DROP COLUMN column_name;
</code></pre></div></div>

<p>ex. “Customers” 테이블에서 “Email” 열을 삭제</p>

<blockquote>
  <p>ALTER TABLE Customers
DROP COLUMN Email;</p>
</blockquote>

<h3 id="열-변경수정">열 변경/수정</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ALTER TABLE table_name
MODIFY COLUMN column_name datatype;
</code></pre></div></div>

<p>ex. “Persons” 테이블에서 “DateOfBirth”라는 열의 데이터 유형을 변경</p>

<blockquote>
  <p>ALTER TABLE Persons
ALTER COLUMN DateOfBirth year;</p>
</blockquote>

<h2 id="constraints제약조건">Constraints(제약조건)</h2>

<ul>
  <li>명령문을 사용하여 테이블을 생성할 때 또는 명령문으로 테이블을 생성한 후에 제약 조건을 지정</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE table_name (
    column1 datatype constraint,
    column2 datatype constraint,
    column3 datatype constraint,
    ....
);
</code></pre></div></div>

<p>제약 조건</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">NOT NULL</code> - 컬럼이 NULL 값을 가질 수 없도록 보장
<code class="language-plaintext highlighter-rouge">UNIQUE</code> - 열의 모든 값이 서로 다른지 확인
<code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> - (A)의 조합 <code class="language-plaintext highlighter-rouge">NOT NULL</code>과 <code class="language-plaintext highlighter-rouge">UNIQUE</code>. 테이블의 각 행을 고유하게 식별
<code class="language-plaintext highlighter-rouge">FOREIGN KEY</code> - 테이블 간의 링크를 파괴하는 작업 방지
<code class="language-plaintext highlighter-rouge">CHECK</code> - 컬럼의 값이 특정 조건을 만족하는지 확인
<code class="language-plaintext highlighter-rouge">DEFAULT</code> - 값이 지정되지 않은 경우 열의 기본값을 설정합니다.
<code class="language-plaintext highlighter-rouge">CREATE INDEX</code> - 데이터베이스에서 데이터를 매우 빠르게 생성하고 검색하는 데 사용</p>
</blockquote>

<h2 id="not-null">NOT NULL</h2>

<ul>
  <li>기본적으로 열은 NULL 값을 보유할 수 있다.</li>
  <li>NOT NULL 제약 조건은 열이 NULL 값을 허용하지 않도록 함</li>
  <li>필드에 항상 값이 포함
    <ul>
      <li>필드에 값을 추가하지 않고는 새 레코드를 삽입하거나 레코드를 업데이트할 수 없다.</li>
    </ul>
  </li>
</ul>

<p>ex. “Persons” 테이블이 생성될 때 “ID”, “LastName” 및 “FirstName” 열이 NULL 값을 허용하지 않도록 함</p>

<blockquote>
  <p>CREATE TABLE Persons (
ID int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255) NOT NULL,
Age int
);</p>
</blockquote>

<h2 id="unique-constraint">UNIQUE Constraint</h2>

<ul>
  <li>열의 모든 값이 서로 다른지 확인</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    UNIQUE (ID)
);
</code></pre></div></div>

<p>ex. 테이블이 이미 생성된 경우 “ID” 열에 대한 제약 조건 을 생성</p>

<blockquote>
  <p>ALTER TABLE Persons
ADD UNIQUE (ID);</p>
</blockquote>

<p>ex. 제약 조건의 이름을 지정하고 UNIQUE여러 열에 대한 제약 조건 을 정의</p>

<blockquote>
  <p>ALTER TABLE Persons
ADD CONSTRAINT UC_Person UNIQUE (ID,LastName);</p>
</blockquote>

<p>ex. 제약 조건을 삭제</p>

<blockquote>
  <p>ALTER TABLE Persons
DROP INDEX UC_Person;</p>
</blockquote>

<h2 id="primary-key">PRIMARY KEY</h2>

<ul>
  <li>고유하게 식별</li>
  <li>UNIQUE 값을 포함해야 하며 NULL 값을 포함할 수 없다.</li>
</ul>

<p>ex. PRIMARY KEY”Persons” 테이블이 생성될 때 “ID” 열에 생성</p>

<blockquote>
  <p>CREATE TABLE Persons (
ID int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Age int,
PRIMARY KEY (ID)
);</p>
</blockquote>

<p>ex. 테이블이 이미 생성된 경우 “ID” 열에 대한 제약 조건 을 생성</p>

<blockquote>
  <p>ALTER TABLE Persons
ADD PRIMARY KEY (ID);</p>
</blockquote>

<p>ex. 제약 조건의 이름을 지정 PRIMARY KEY하고 여러 열에 제약 조건 을 정의</p>

<blockquote>
  <p>ALTER TABLE Persons
ADD CONSTRAINT PK_Person PRIMARY KEY (ID,LastName);</p>
</blockquote>

<p>ex. 제약 조건 을 삭제</p>

<blockquote>
  <p>ALTER TABLE Persons
DROP PRIMARY KEY;</p>
</blockquote>

<h2 id="foreign-key">FOREIGN KEY</h2>

<ul>
  <li>테이블 간의 링크를 파괴하는 작업을 방지하는 데 사용</li>
  <li>외래 키가 있는 테이블이 자식 테이블, 기본 키가 있는 테이블이 참조 또는 부모 테이블</li>
</ul>

<p>ex. FOREIGN KEY”Orders” 테이블이 생성될 때 “PersonID” 열에 생성</p>

<blockquote>
  <p>CREATE TABLE Orders (</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OrderID int NOT NULL,
OrderNumber int NOT NULL,
PersonID int,
PRIMARY KEY (OrderID),
FOREIGN KEY (PersonID) REFERENCES Persons(PersonID)
</code></pre></div></div>

<p>);</p>

<p>ex. “Orders” 테이블이 이미 생성된 경우 “PersonID” 열에 대한 제약 조건 을 생성</p>

<blockquote>
  <p>ALTER TABLE Orders
ADD FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);</p>
</blockquote>

<p>ex. 제약 조건의 이름을 지정 FOREIGN KEY하고 여러 열에 제약 조건 을 정의</p>

<blockquote>
  <p>ALTER TABLE Orders
ADD CONSTRAINT FK_PersonOrder
FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);</p>
</blockquote>

<p>ex. 제약 조건 을 삭제</p>

<blockquote>
  <p>ALTER TABLE Orders
DROP FOREIGN KEY FK_PersonOrder;</p>
</blockquote>

<h2 id="check-constraint">CHECK Constraint</h2>

<ul>
  <li>열에 배치할 수 있는 값 범위를 제한</li>
  <li>제약 조건 을 정의하면 이 열에 대해 특정 값만 허용</li>
</ul>

<p>ex. CHECK”Persons” 테이블이 생성될 때 “Age” 열에 대한 제약 조건을 생성
사람의 나이는 18 세 이상</p>

<blockquote>
  <p>CREATE TABLE Persons (</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Age int,
CHECK (Age&gt;=18)
</code></pre></div></div>

<p>);</p>

<p>ex. 제약 조건의 이름을 지정 CHECK하고 여러 열에 제약 조건 을 정의</p>

<blockquote>
  <p>CREATE TABLE Persons (</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Age int,
City varchar(255),
CONSTRAINT CHK_Person CHECK (Age&gt;=18 AND City='Sandnes')
</code></pre></div></div>

<p>);</p>

<p>ex. 테이블이 이미 생성된 경우 “Age” 열에 대한 제약 조건</p>

<blockquote>
  <p>ALTER TABLE Persons
ADD CHECK (Age&gt;=18);</p>
</blockquote>

<p>ex. 제약 조건의 이름을 지정 CHECK하고 여러 열에 제약 조건 을 정의</p>

<blockquote>
  <p>ALTER TABLE Persons
ADD CONSTRAINT CHK_PersonAge CHECK (Age&gt;=18 AND City=’Sandnes’);</p>
</blockquote>

<p>ex. 제약 조건 을 삭제</p>

<blockquote>
  <p>ALTER TABLE Persons
DROP CHECK CHK_PersonAge;</p>
</blockquote>

<h2 id="default-constraint">DEFAULT Constraint</h2>

<ul>
  <li>열의 기본값을 설정</li>
  <li>다른 값이 지정되지 않은 경우 기본값이 모든 새 레코드에 추가</li>
</ul>

<p>ex. “Persons” 테이블이 생성될 때 “City” 열에 대한 값을 설정</p>

<blockquote>
  <p>CREATE TABLE Persons (</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Age int,
City varchar(255) DEFAULT 'Sandnes'
</code></pre></div></div>

<p>);</p>

<p>ex. 테이블이 이미 생성된 경우 “City” 열에 대한 제약 조건 을 생성</p>

<blockquote>
  <p>ALTER TABLE Persons
ALTER City SET DEFAULT ‘Sandnes’;</p>
</blockquote>

<p>ex. 제약 조건 을 삭제</p>

<blockquote>
  <p>ALTER TABLE Persons
ALTER City DROP DEFAULT;</p>
</blockquote>

<h2 id="create-index">CREATE INDEX</h2>

<ul>
  <li>테이블에 인덱스를 생성하는 데 사용
    <ul>
      <li>인덱스는 다른 방법보다 더 빠르게 데이터베이스에서 데이터를 검색하는 데 사용</li>
      <li>자주 검색되는 열에만 인덱스사용(업데이트 시간이 오래 걸림)</li>
    </ul>
  </li>
  <li>중복값 허용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE INDEX index_name
ON table_name (column1, column2, ...);
</code></pre></div></div>

<ul>
  <li>중복값 불허용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE UNIQUE INDEX index_name
ON table_name (column1, column2, ...);
</code></pre></div></div>

<p>ex. “Persons” 테이블의 “LastName” 열에 “idx_lastname”이라는 인덱스를 생성</p>

<blockquote>
  <p>CREATE INDEX idx_lastname
ON Persons (LastName);</p>
</blockquote>

<p>ex. 열 조합에 대한 인덱스를 생성</p>

<blockquote>
  <p>CREATE INDEX idx_pname
ON Persons (LastName, FirstName);</p>
</blockquote>

<p>ex. 테이블에서 인덱스를 삭제</p>

<blockquote>
  <p>ALTER TABLE table_name
DROP INDEX index_name;</p>
</blockquote>

<h2 id="auto-increment">AUTO INCREMENT</h2>

<ul>
  <li>새 레코드가 테이블에 삽입될 때 고유 번호가 자동으로 생성</li>
  <li>기본 키 필드</li>
</ul>

<blockquote>
  <p>CREATE TABLE Persons (</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Personid int NOT NULL AUTO_INCREMENT,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Age int,
PRIMARY KEY (Personid)
</code></pre></div></div>

<p>);</p>

<h2 id="dates">Dates</h2>

<ul>
  <li>DATE - YYYY-MM-DD 형식</li>
  <li>DATETIME - 형식: YYYY-MM-DD HH:MI:SS</li>
  <li>TIMESTAMP - 형식: YYYY-MM-DD HH:MI:SS</li>
  <li>YEAR - YYYY 또는 YY 형식</li>
</ul>

<p>ex.</p>

<blockquote>
  <p>SELECT * FROM Orders WHERE OrderDate=’2008-11-11’</p>
</blockquote>

<h2 id="create-view">CREATE VIEW</h2>

<ul>
  <li>SQL 문의 결과 집합을 기반으로 하는 가상 테이블</li>
  <li>실제 테이블과 마찬가지로 행과 열을 포함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
</code></pre></div></div>

<p>ex. 브라질의 모든 고객을 표시하는 보기를 생성</p>

<blockquote>
  <p>CREATE VIEW [Brazil Customers] AS
SELECT CustomerName, ContactName
FROM Customers
WHERE Country = ‘Brazil’;</p>
</blockquote>

<p>위에꺼랑 같은 보기</p>

<blockquote>
  <p>SELECT * FROM [Brazil Customers];</p>
</blockquote>

<h3 id="create-or-replace-viewview-업데이트">CREATE OR REPLACE VIEW(VIEW 업데이트)</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE OR REPLACE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
</code></pre></div></div>

<p>ex. Brazil Customers” 보기에 “City” 열을 추가</p>

<blockquote>
  <p>CREATE OR REPLACE VIEW [Brazil Customers] AS
SELECT CustomerName, ContactName, City
FROM Customers
WHERE Country = ‘Brazil’;</p>
</blockquote>

<h3 id="drop-view">DROP VIEW</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DROP VIEW view_name;
</code></pre></div></div>

<blockquote>
  <p>DROP VIEW [Brazil Customers];</p>
</blockquote>]]></content><author><name>Gardenia</name></author><category term="Tips" /><category term="Tips" /><summary type="html"><![CDATA[SQL 정리하기]]></summary></entry><entry><title type="html">[TIL]시간복잡도</title><link href="/til/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/" rel="alternate" type="text/html" title="[TIL]시간복잡도" /><published>2022-07-10T00:00:00+09:00</published><updated>2022-07-10T00:00:00+09:00</updated><id>/til/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84</id><content type="html" xml:base="/til/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/"><![CDATA[<h1 id="-알아보자-시간-복잡도">🌱 알아보자 시간 복잡도!</h1>

<ul>
  <li>알고리즘이 얼마나 걸리느냐</li>
</ul>

<blockquote>
  <p>시간복잡도 = 알고리즘을 구성한 명령어가 실행된 횟수</p>
</blockquote>

<p><strong>시간복잡도의 종류</strong></p>

<table>
  <tbody>
    <tr>
      <td>O()</td>
      <td>빅오</td>
      <td>최악 시간</td>
      <td>가장 많이 쓰임 실행시간의 상한</td>
    </tr>
    <tr>
      <td>Ω()</td>
      <td>오메가</td>
      <td>최상 시간</td>
      <td>실행시간의 하한</td>
    </tr>
    <tr>
      <td>Θ()</td>
      <td>세타</td>
      <td>평균 시간</td>
      <td>실행시간의 평균</td>
    </tr>
  </tbody>
</table>

<h2 id="big-o-계산-규칙">Big-O 계산 규칙</h2>

<ul>
  <li>
    <ol>
      <li>Worst Case
        <ul>
          <li>항상 최악의 상황을 고려</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Remove Constants
        <ul>
          <li>상수를 제거 하라</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Different Terms for Inputs
        <ul>
          <li>인자 값이 다를 경우 따로 계산</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Drop Non Dominants
        <ul>
          <li>가장 높은 차수만 남김</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="o1---constant-time">O(1) - Constant Time</h3>

<ul>
  <li>입력 공간에 대해 변하지 않음</li>
  <li>상수 시간이라고 부름</li>
  <li>n의 값이 얼마나 크든 상관 ❌</li>
  <li>단 한 번만 이루어지면 됨</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function exampleO1(arr){
  console.log(arr[0]);
}
</code></pre></div></div>

<h3 id="on---linear-time">O(n) - Linear time</h3>

<ul>
  <li>선형 시간</li>
  <li>최악의 경우 n번의 연산을 수행해야 하는 알고리즘에 적용</li>
  <li>입력 데이터의 크기에 비례해서 처리시간도 늘어나는 알고리즘을 표현할 때 사용</li>
  <li>코드를 n번 반복</li>
  <li>e.g. 0부터 n-1까지 숫자 출력</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function exampleOn(n) {
    for (let i = 0; i &lt; n; i++) {
        console.log(i);
    }
}
</code></pre></div></div>

<h3 id="on2---quadratic-time">O(n^2) - Quadratic Time</h3>

<ul>
  <li>2차 시간</li>
  <li>입력 데이터의 크기의 제곱만큼 처리시간이 걸리는 알고리즘을 표현할 때 사용</li>
  <li>n * n번 수행</li>
  <li>e.g. 선택 정렬, 삽입 정렬, 버블 정렬</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function exampleOn2(n) {
    for (let i = 0; i &lt; n; i++) {
        console.log(i);
        for (let j = i; j &lt; n; j++) {
            console.log(j);
        }
    }
}
</code></pre></div></div>

<h3 id="olog-n---log">O(log n) - Log</h3>

<ul>
  <li>이진 탐색 등의 알고리즘을 표현할 때 사용</li>
  <li>e.g. 2의 2승 부터 n승까지 출력</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function exampleLogn(n) {
    for (let i = 2; i &lt;= n; i*2) {
        console.log(i);
    }
}

</code></pre></div></div>

<h1 id="참고">참고</h1>

<p><a href="https://itprogramming119.tistory.com/entry/Javascript-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EC%A0%95%EB%A6%AC-%EB%B0%8F-%EC%98%88%EC%A0%9C">코딩병원 블로그</a><br />
<a href="https://overcome-the-limits.tistory.com/18">Plus Ultra 블로그</a><br />
<a href="https://pizzasheepsdev.tistory.com/3">개발하는 피자 양목장 블로그</a></p>]]></content><author><name>Gardenia</name></author><category term="TIL" /><category term="TIL" /><summary type="html"><![CDATA[시간복잡도 이해하기]]></summary></entry><entry><title type="html">[TIL]호이스팅</title><link href="/til/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/" rel="alternate" type="text/html" title="[TIL]호이스팅" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>/til/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85</id><content type="html" xml:base="/til/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/"><![CDATA[<h1 id="-what-is-hoisting">🌱 WHAT IS HOISTING❓</h1>

<blockquote>
  <p>코드가 실행하기 전 <code class="language-plaintext highlighter-rouge">변수(함수)선언</code>이 해당 스코프의 최상단으로 끌어 올려진 것 같은 현상</p>
</blockquote>

<ul>
  <li>JS는 함수가 실행되기전 해당 함수를 한 번 흝는다.</li>
  <li>그 때 함수 안에 존재하는 변수/함수를 기억하고 있다가 사용한다.</li>
  <li>실제로 코드가 올려지는 것은 아니고 JS 내부적으로 올려서 처리하는 것(메모리 변화❌)</li>
</ul>

<h1 id="-호이스팅이-되는-것">🌱 호이스팅이 되는 것</h1>

<p><code class="language-plaintext highlighter-rouge">var</code>변수 선언과 <code class="language-plaintext highlighter-rouge">함수선언문</code>에서만 발생</p>

<h1 id="-호이스팅-우선-순위">🌱 호이스팅 우선 순위</h1>

<ul>
  <li><strong>변수선언</strong>이 함수보더 우선순위</li>
  <li>할당되지 않은 변수보다는 할당된 함수가 더 우선순위를 가짐</li>
</ul>

<h1 id="주의사항">주의사항</h1>

<ul>
  <li>코드 가독성과 유지보수를 위해 호이스팅이 일어나지 않게 코드를 짜는 것이 중요❗️❗️❗️
    <ul>
      <li>함수 변수를 처음부터 상단에 짠다.</li>
      <li>let, const를 사용한다.</li>
    </ul>
  </li>
</ul>

<h1 id="me">ME</h1>

<ul>
  <li>호이스팅을 전에 잘 못 이해했어서 애초에 선언을 위해 해주는 것이 호이스팅이라고 생각했는데 이번에 다시 정리하며 새롭게 익혔다!</li>
</ul>

<h1 id="참조">참조</h1>

<table>
  <tbody>
    <tr>
      <td><a href="https://hanamon.kr/javascript-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80-hoisting/">하나몬님 블로그</a></td>
    </tr>
    <tr>
      <td><a href="https://velog.io/@design0728/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85">EJlog님 블로그</a></td>
    </tr>
  </tbody>
</table>]]></content><author><name>Gardenia</name></author><category term="TIL" /><category term="TIL" /><category term="Hoisting" /><category term="JavaScript" /><summary type="html"><![CDATA[WHAT IS HOISTING IN JAVASCRIPT❔❓]]></summary></entry><entry><title type="html">[Tips]JS 함수 정리</title><link href="/tips/JS%ED%95%A8%EC%88%98-%EC%A0%95%EB%A6%AC/" rel="alternate" type="text/html" title="[Tips]JS 함수 정리" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>/tips/JS%ED%95%A8%EC%88%98-%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="/tips/JS%ED%95%A8%EC%88%98-%EC%A0%95%EB%A6%AC/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">알파벳 순 정리</code></p>]]></content><author><name>Gardenia</name></author><category term="Tips" /><category term="Tips" /><category term="JavaScript" /><category term="Function" /><summary type="html"><![CDATA[JS 내부 함수 짧은 정리]]></summary></entry><entry><title type="html">[Project]makeyourcards</title><link href="/project/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-makeyourcards/" rel="alternate" type="text/html" title="[Project]makeyourcards" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>/project/%5B%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%5D-makeyourcards</id><content type="html" xml:base="/project/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-makeyourcards/"><![CDATA[<h1 id="프로젝트-시작">프로젝트 시작</h1>

<p>자다가 문득 토이프로젝트라고 어려울 꺼 할 일 있어?
최대ㅐㅐㅐㅐ한 간단하게 한 번 해보자!!
라고 생각하다가</p>

<p>그냥 간단한 카드 같은거 만들어서 카톡으로 보낼 수 있고 카드 사진 저장 할 수 있는거 만들어 볼까 생각함</p>

<p>가장 간단한 기능</p>

<ol>
  <li>열몇개 기본 사진 있고 내가 만들고 싶은 카드 추가 가능 기능 있음</li>
  <li>텍스트 입력하면 카드에 입력되고</li>
  <li>그 카드를 바로 카카오톡으로 보내거나 저장 가능하게</li>
  <li>카드는 일단 플립처럼 카드 열어보는 거고</li>
  <li>카톡 전달
    <ul>
      <li>접었을 때는 to. from ~~ 적히고</li>
      <li>상대방이 열면 카드가 열림</li>
    </ul>
  </li>
  <li>저장은 그냥 카드모양 길게 보임</li>
  <li>로그인(일반 이메일 로긴, 카카오톡 로긴, 구글 로긴 세개 만들기) 했을 때 내가 만든 카드가 저장 되어 있어야 함(이거슨 옵션!)</li>
</ol>

<h1 id="개발-툴">개발 툴</h1>

<ul>
  <li>FE: TS, REACT</li>
  <li>BE: express? nextjs? 고민중</li>
  <li>DevOps: heroku? 무료 도메인으로 해보자!! 돈없다!!</li>
</ul>]]></content><author><name>Gardenia</name></author><category term="Project" /><category term="Project" /><category term="TypeScript" /><summary type="html"><![CDATA[1인 프로젝트의 시작]]></summary></entry><entry><title type="html">[Next.JS]NEXT.JS 시작하기</title><link href="/next.js/nextjs-%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/" rel="alternate" type="text/html" title="[Next.JS]NEXT.JS 시작하기" /><published>2022-07-09T00:00:00+09:00</published><updated>2022-07-09T00:00:00+09:00</updated><id>/next.js/nextjs-%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94</id><content type="html" xml:base="/next.js/nextjs-%EB%85%B8%EB%A7%88%EB%93%9C%EC%BD%94%EB%8D%94/"><![CDATA[<table>
  <tbody>
    <tr>
      <td><a href="https://nomadcoders.co/nextjs-fundamentals">노마드코더 강의</a></td>
    </tr>
    <tr>
      <td><a href="https://kyounghwan01.github.io/blog/React/next/basic/#next-js%E1%84%80%E1%85%A1-%E1%84%8C%E1%85%A6%E1%84%80%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%8C%E1%85%AE%E1%84%8B%E1%85%AD-%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC">기억보다 기록을-next</a></td>
    </tr>
  </tbody>
</table>]]></content><author><name>Gardenia</name></author><category term="Next.JS" /><category term="Next.JS" /><category term="Nomadcoders" /><summary type="html"><![CDATA[노마드코더 NEXT,JS 무료강의]]></summary></entry></feed>